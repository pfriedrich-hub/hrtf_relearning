# Auto-converted from notebook: hrtf_identification_solution.ipynb

import pyfar as pf
import sofar as sf
import matplotlib.pyplot as plt
import os
%matplotlib inline

print(f'last tested with pyfar v{pf.__version__} and sofar v{sf.__version__}')

data_dir = os.path.join('..', '..', 'Resources')
data = pf.io.read(os.path.join(data_dir, 'hrir_measurement.far'))

# this is a reference HRIR, directly from the FABIAN database. In this case
# the low frequency extrapolation was done with numerically simulated data
hrir_reference = data['hrir']

# this is a sweep recorded at the ears of the same dummy head
# (It is actually a simulation of that, which was generated by convolving a
# sweep with the reference HRTF, adding some noise, reflections, and the
# frequency response of a loudspeaker)
hrir_recorded = data['hrir_recorded']

# this is the sweep signal itself
reference = data['reference']

# get familiar with the data and generate time frequency plots
pf.plot.time_freq(reference)


# sweep inversion
reference_inverted = pf.dsp.regularized_spectrum_inversion(
    reference, frequency_range=(20, 19.75e3))

ax = pf.plot.freq(reference, label='sweep')
ax = pf.plot.freq(reference_inverted, label='inverted sweep')
ax.legend(loc='lower left')

hrir_deconvolved = hrir_recorded * reference_inverted

ax = pf.plot.time_freq(hrir_deconvolved, unit='samples')
ax[0].set_xlim(0, 1e3)
ax[1].set_ylim(-40, 20)

# apply time window
hrir_windowed = pf.dsp.time_window(
    hrir_deconvolved, (170, 335), 'boxcar', unit='samples', crop='window')

# pad to original length for plotting and further processing
hrir_windowed = pf.dsp.pad_zeros(
    hrir_windowed, hrir_deconvolved.n_samples-hrir_windowed.n_samples)

ax = pf.plot.time_freq(
    hrir_deconvolved, unit='samples', dB_time=True, label='before windowing')
pf.plot.time_freq(
    hrir_windowed, unit='samples', dB_time=True, label='after windowing')
ax[0].set_xlim(0, 1e3)
ax[1].set_ylim(-40, 20)
ax[1].legend(loc='lower left')

# low-pass HRIR using cross-over filter
hrir_low = pf.dsp.filter.crossover(
    pf.signals.impulse(hrir_windowed.n_samples), 4, 400)[0]

# high-pass HRIR using same cross over
hrir_high = pf.dsp.filter.crossover(hrir_windowed, 4, 400)[1]

ax = pf.plot.time_freq(
    hrir_low, unit='samples', dB_time=True, label='low-frequency HRTF')
pf.plot.time_freq(
    hrir_high, unit='samples', dB_time=True, label='high-frequency HRTF')
ax[0].set_xlim(0, 1e3)
ax[1].set_ylim(-40, 20)
ax[1].legend(loc='lower left')

# delay impulse according to the delay of the HRIR
hrir_low_delayed = pf.dsp.fractional_time_shift(
    hrir_low, pf.dsp.find_impulse_response_delay(hrir_windowed))

# add impulse and HRIR
hrir_extrapolated = hrir_low_delayed + hrir_high

ax = pf.plot.time_freq(
    hrir_low_delayed, unit='samples', dB_time=True,
    label='low-frequency HRTF', ls='--')
pf.plot.time_freq(
    hrir_high, unit='samples', dB_time=True,
    label='high-frequency HRTF', ls='--')
pf.plot.time_freq(
    hrir_extrapolated, unit='samples', dB_time=True,
    label='extrapolated HRTF')
ax[0].set_xlim(0, 1e3)
ax[1].set_ylim(-40, 20)
ax[1].legend(loc='lower left')


# window to final length
n_start = 30
n_samples = 256
hrir_final = pf.dsp.time_window(
    hrir_extrapolated, (n_start, n_start + n_samples), 'boxcar',
    crop='window')

# compare against full length (pad zeros to increase FFT resolution)
ax = pf.plot.time_freq(hrir_extrapolated, label='full-length')
pf.plot.time_freq(
    pf.dsp.pad_zeros(hrir_final, hrir_extrapolated.n_samples - n_samples),
    label='windowed')
ax[1].legend(loc='lower left')
ax[0].set_xlim(0, 6e-3)
ax[1].set_ylim(-25, 25)


ax = pf.plot.time_freq(hrir_reference, label='reference')
pf.plot.time_freq(hrir_final, label='estimated')
ax[1].legend(loc='lower left')
ax[0].set_xlim(0, 6e-3)
ax[1].set_ylim(-25, 25)


